// src/components/mandala/client.tsx
"use client";

import { useEffect, useRef } from "react";
import { BODY_ORDER, type SegmentsPayload, type HoverInfo } from "@/lib/mandala/constants";
import { injectArcStyles } from "@/lib/mandala/styles";
import { applyRingLayout } from "@/lib/mandala/ringLayout";
import { buildSegmentedRing } from "@/lib/mandala/buildRing";
import { animateRingIn, animateRingMove } from "@/lib/mandala/animations";

type MandalaClientProps = {
  year: number;
  visiblePlanets: Record<string, boolean>;
  onHover?: (info: HoverInfo) => void;
  onSelect?: (info: HoverInfo) => void; 
  selected?: HoverInfo | null; 
};

export default function MandalaClient({ year, visiblePlanets, onHover, onSelect, selected }: MandalaClientProps) {
  const prevRadiusRef = useRef<Map<string, number>>(new Map());
  const visiblePlanetsRef = useRef<Record<string, boolean>>(visiblePlanets);

  const svgRef = useRef<SVGSVGElement | null>(null);

  // “Data for the current year” (in-memory only; not a caching “system”)
  const transitsRef = useRef<SegmentsPayload["transits"] | null>(null);
  const yearStartRef = useRef<Date | null>(null);
  const yearEndRef = useRef<Date | null>(null);
  const allIdsRef = useRef<string[]>([]);

  useEffect(() => {
    visiblePlanetsRef.current = visiblePlanets;
  }, [visiblePlanets]);

  useEffect(() => {
    const svgEl = document.querySelector("#MandalaSvg");
    if (!(svgEl instanceof SVGSVGElement)) return;

    svgRef.current = svgEl;
    injectArcStyles();

    return () => {
      const svg = svgRef.current;
      if (!svg) return;

      // remove only generated segment groups
      for (const id of BODY_ORDER) {
        const segGroup = svg.querySelector(`#${id}-segments`);
        if (segGroup instanceof SVGGElement) segGroup.remove();
      }

      // clear labels, but don’t remove the layer node
      const labelLayer = svg.querySelector("#GateLabels");
      if (labelLayer instanceof SVGGElement) labelLayer.innerHTML = "";
    };
  }, []);

  function applySelectedClass(svg: SVGSVGElement, selected: HoverInfo | null) {
  svg.querySelectorAll(".seg-wrap.is-selected").forEach((el) => el.classList.remove("is-selected"));
  if (!selected) return;

  const { planet, gate } = selected;
  const selector = `.seg-wrap[data-planet="${planet}"][data-gate="${gate}"]`;
  const el = svg.querySelector(selector);
  if (el) el.classList.add("is-selected");
}


  async function fetchYearSegments(y: number): Promise<SegmentsPayload> {
    const res = await fetch(`/api/segments?year=${y}`);
    if (!res.ok) throw new Error(`segments fetch failed ${res.status}`);
    return res.json();
  }

  function getAllIds(svg: SVGSVGElement, transits: SegmentsPayload["transits"]) {
    // Only include bodies that actually exist in the payload
    return BODY_ORDER.filter((id) => transits[id]);
  }

  function getActiveIds(allIds: string[], vp: Record<string, boolean>) {
    return allIds.filter((id) => vp[id] !== false);
  }

  function rebuildActiveRings(svg: SVGSVGElement, activeIds: string[]) {
    const transits = transitsRef.current;
    const YEAR_START = yearStartRef.current;
    const YEAR_END = yearEndRef.current;
    if (!transits || !YEAR_START || !YEAR_END) return;

    // Clear labels and rebuild labels for currently-active rings.
    // (BuildRing currently writes labels into a shared GateLabels layer.)
    const labelLayer = svg.querySelector("#GateLabels");
    if (labelLayer instanceof SVGGElement) labelLayer.innerHTML = "";

    const prevRadius = prevRadiusRef.current;

    for (const id of activeIds) {
      const hadBefore = prevRadius.has(id);

      const built = buildSegmentedRing({
        svg,
        planetId: id,
        transits,
        yearStart: YEAR_START,
        yearEnd: YEAR_END,
        onHover,
        onSelect,
      });

      if (!built) continue;

      const base = svg.querySelector(`#${id}`);
      if (base instanceof SVGCircleElement) {
        const newR = parseFloat(base.getAttribute("r") || "0");

        if (!hadBefore) {
          animateRingIn(svg, id);
          prevRadius.set(id, newR);
        } else {
          const oldR = prevRadius.get(id) ?? newR;
          animateRingMove(svg, id, oldR, newR);
          prevRadius.set(id, newR);
        }
      }
    }
  }

  function applyVisibility(svg: SVGSVGElement, allIds: string[], vp: Record<string, boolean>) {
    for (const id of allIds) {
      const on = vp[id] !== false;

      const base = svg.querySelector(`#${id}`);
      if (base instanceof SVGCircleElement) base.style.display = on ? "" : "none";

      const segGroup = svg.querySelector(`#${id}-segments`);
      if (segGroup instanceof SVGGElement) segGroup.style.display = on ? "" : "none";
    }
  }

  async function initYear(y: number) {
    const svg = svgRef.current;
    if (!svg) return;

    const payload = await fetchYearSegments(y);

    const yearText = svg.querySelector("#YearLabel tspan");
    if (yearText) yearText.textContent = String(payload.year);

    transitsRef.current = payload.transits;
    yearStartRef.current = new Date(payload.year_start_utc);
    yearEndRef.current = new Date(payload.year_end_utc);

    // clear any previously generated segment groups
    for (const id of BODY_ORDER) {
      const segGroup = svg.querySelector(`#${id}-segments`);
      if (segGroup instanceof SVGGElement) segGroup.remove();
    }

    // reset label content
    const labelLayer = svg.querySelector("#GateLabels");
    if (labelLayer instanceof SVGGElement) labelLayer.innerHTML = "";

    const allIds = getAllIds(svg, payload.transits);
    allIdsRef.current = allIds;

    const vp = visiblePlanetsRef.current;
    const activeIds = getActiveIds(allIds, vp);

    applyRingLayout(svg, activeIds);
    rebuildActiveRings(svg, activeIds);
    applyVisibility(svg, allIds, vp);
    applySelectedClass(svg, selected ?? null);

    // (optional debug)
    (window as any).transits = payload.transits;
    (window as any).YEAR_START = yearStartRef.current;
    (window as any).YEAR_END = yearEndRef.current;
  }

  function updateVisibleOnly() {
    const svg = svgRef.current;
    const transits = transitsRef.current;
    if (!svg || !transits) return;

    const allIds = allIdsRef.current;
    const vp = visiblePlanetsRef.current;
    const activeIds = getActiveIds(allIds, vp);

    applyRingLayout(svg, activeIds);

    // Rebuild active rings (no fetch). This keeps labels correct and allows radius animations.
    rebuildActiveRings(svg, activeIds);
    applyVisibility(svg, allIds, vp);
    applySelectedClass(svg, selected ?? null);

  }

  // Year change = fetch + rebuild
  useEffect(() => {
    initYear(year).catch(console.warn);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [year]);

  // Planet toggles = no fetch, just relayout + rebuild segments/labels from existing data
  useEffect(() => {
    updateVisibleOnly();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [visiblePlanets]);

  useEffect(() => {
    const svg = svgRef.current;
    if (!svg) return;
    applySelectedClass(svg, selected ?? null);
  }, [selected]);


  return null;
}
